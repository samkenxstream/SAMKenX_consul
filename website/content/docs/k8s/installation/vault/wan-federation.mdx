---
layout: docs
page_title: Wan Federation with Vault as Secrets Backend
description: >-
  End to end example of WAN Federation using Vault as secrets backend for Consul on Kubernetes.
---

# Wan Federation with Vault as Secrets Backend

## Overview
TODO:  DESCRIBE WHAT WE RAE DOING IN THIS END TO END EXAMPLE

## Prerequisites
- Two Kuberentes clusters (one for each datacenter)
- Kubernetes distribution must support load balancer services (NOTE: it's possible to make it work without load balancers, but these instructions use load balancers for simplicity).

### Deploy Vault cluster

In this setup, we will deploy Vault server in the dc1 k8s cluster 
and then will configure our Vault Helm installation in the dc2 k8s cluster to use it as an external server. 
This way we will have a single vault server cluster that will be use by both Consul datacenters.

### Vault server and injector in DC1

For demonstration purposes, we will deploy Vault server in dev mode, although for production installations, this is not recommended. 

Target your dc1 kubernetes cluster and deploy the Vault Helm chart with the following Helm values:

```yaml
# vault-dc1.yaml
server:
  dev:
    enabled: true
  service:
    enabled: true
    type: LoadBalancer
ui:
  enabled: true
```

```shell
$ helm install vault-dc1 -f vault-dc1.yaml hashicorp/vault --wait
```

## Systems Integation

## One time set up on Vault
### Enable Vault KV Secrets Engine - Version 2
The following secrets will be stored in Vault KV secrets engine:
- Gossip encryption key ([`global.gossipEncryption`]())
- ACL Replication token ([`global.acls.replicationToken`](/docs/k8s/helm#v-global-acls-replicationtoken))

Therefore, we must enable the [Vault KV secrets engine - Version 2](https://www.vaultproject.io/docs/secrets/kv/kv-v2).

```shell-session
$ vault secrets enable -path=consul kv-v2
```

### Enable Vault PKI Engine

The Vault PKI Engine must be enabled in order to leverage Vault for issuing Consul Server TLS certificates.

* Enable the PKI Secrets Engine:

  ```shell-session
  $ vault secrets enable pki
  ```

* Tune the engine to enable longer TTL:

  ```shell-session
  $ vault secrets tune -max-lease-ttl=87600h pki
  ```

* Generate the root CA

  ```shell-session
  $ vault write pki/root/generate/internal common_name="Consul CA" ttl=87600
  ```

## Set up per Consul data center
### DC1 Datacenter
##### Set Environment Variables to ensure integration consistency
    ```shell
    $ export DATACENTER=dc1
    ```

    ```shell
    export VAULT_AUTH_METHOD_NAME=kubernetes-${DATACENTER}
    ```

### Install Vault Injector in your Consul k8s cluster
A minimal valid installation of Vault Kubernetes must include the Agent Injector which is utilized for accessing secrets from Vault. 
In DC1, we will not have to configure `injector.externalvaultaddr` value because the Vault Server is in the same DC1 cluster.

```shell
$ cat <<EOF >> vault-injector.yaml
# vault-injector.yaml
server:
  enabled: false
injector:
  enabled: true
  authPath: auth/${VAULT_AUTH_METHOD_NAME}
EOF
``` 

```shell
$ helm install vault-${DATACENTER} -f vault-injector.yaml hashicorp/vault --wait
```

### Configure the Kubernetes Auth Method in Vault for the data center
#### Enable the Auth Method
Enable the Vault Kubernetes auth method.

```shell
$ vault auth enable -path=kubernetes-${DATACENTER} kubernetes
```

#### Configure Auth Method with JWT token of service account

First, while targeting your Consul cluster, get the externally reachable address of the Consul Kubernetes cluster.

```
$ export KUBE_API_URL=$(kubectl config view -o jsonpath="{.clusters[?(@.name == \"$(kubectl config current-context)\")].cluster.server}")
```

```shell-session
$ vault write auth/kubernetes/config \
    token_reviewer_jwt="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
    kubernetes_host="https://$KUBE_API_URL:443" \
    kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
```

#### Enable Vault as the secrets backend in the Consul data center
Finally, you will configure the Consul on Kubernetes helm chart for the data center to enable Vault as the Secrets backend.  However, you will not yet apply the Helm chart.  A complete chart is applied at the end of the Data Integration section.

<CodeBlockConfig filename="values.yaml">

```yaml
global:
  secretsBackend:
    vault:
      enabled: true
```

</CodeBlockConfig>


### DC2 Datacenter
##### Set Environment Variables to ensure integration consistency
    ```shell
    $ export DATACENTER=dc2
    ```

    ```shell
    export VAULT_AUTH_METHOD_NAME=kubernetes-${DATACENTER}
    ```
Get the external IP or DNS name of the Vault server load balancer. 
    - On GKE or AKS, it'll be an IP:
    ```shell
    $ export VAULT_SERVER_HOST=$(kubectl get svc vault-dc1 -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
    ```
    - On EKS, it'll be a hostname:
    ```shell
    $ export VAULT_SERVER_HOST=$(kubectl get svc vault-dc1 -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
    ```

    ```shell
    $ export VAULT_ADDR=http://${VAULT_SERVER_HOST}:8200
    ```

### Install Vault Injector in your Consul k8s cluster
A minimal valid installation of Vault Kubernetes must include the Agent Injector which is utilized for accessing secrets from Vault. 
In DC2, we will have to configure `externalvaultaddr` value point to the external address of the Vault server in DC1.

```shell
$ cat <<EOF >> vault-injector.yaml
# vault-injector.yaml
server:
  enabled: false
injector:
  enabled: true
  externalVaultAddr: $VAULT_ADDR
  authPath: auth/${VAULT_AUTH_METHOD_NAME}
EOF
``` 

```shell
$ helm install vault-${DATACENTER} -f vault-injector.yaml hashicorp/vault --wait
```

### Configure the Kubernetes Auth Method in Vault for the data center
#### Enable the Auth Method
Enable the Vault Kubernetes auth method.

```shell
$ vault auth enable -path=kubernetes-${DATACENTER} kubernetes
```

#### Configure Auth Method with JWT token of service account

First, while targeting your Consul cluster, get the externally reachable address of the Consul Kubernetes cluster.

```
$ export KUBE_API_URL=$(kubectl config view -o jsonpath="{.clusters[?(@.name == \"$(kubectl config current-context)\")].cluster.server}")
```

```shell-session
$ vault write auth/kubernetes/config \
    token_reviewer_jwt="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
    kubernetes_host="https://$KUBE_API_URL:443" \
    kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
```

#### Enable Vault as the secrets backend in the Consul data center
Finally, you will configure the Consul on Kubernetes helm chart for the data center to enable Vault as the Secrets backend.  However, you will not yet apply the Helm chart.  A complete chart is applied at the end of the Data Integration section.

<CodeBlockConfig filename="values.yaml">

```yaml
global:
  secretsBackend:
    vault:
      enabled: true
```

</CodeBlockConfig>





## Data Integration
## Overview
To use an Vault as the Service Mesh Certificate Provider on Kubernetes, we will need to modify the steps outlined in the [Data Integration](/docs/k8s/installation/vault/data-integration) section:

- One time set up in Vault
  1. Store the secret in Vault.
  1. Create a Vault policy that authorizes the desired level of access to the secret.
- Set up per Consul data center
  1. Create Vault Kubernetes auth roles that link the policy to each Consul on Kubernetes service account that requires access.
  1. Configure the Vault Kubernetes auth role in the Consul on Kubernetes helm chart.

## One time set up in Vault
### Store the secret in Vault
This step is not valid to this use case because we are not storing a single secret.  We are configuring Vault as a provider to mint certificates on an ongaing basis.  
### Create a Vault policy that authorizes the desired level of access to the secret

To configure [Vault as the provider](/docs/connect/ca/vault) for the Consul service mesh certificates,
you will first need to decide on the type of policy that is suitable for you.
To see the permissions that Consul would need in Vault, please see [Vault ACL policies](/docs/connect/ca/vault#vault-acl-policies)
documentation.

## Set up per Consul data center
### Create Vault Kubernetes auth roles that link the policy to each Consul on Kubernetes service account that requires access
Next, you will create Kubernetes auth roles for the Consul servers:

```shell-session
$ vault write auth/kubernetes/role/consul-server \
    bound_service_account_names=<Consul server service account> \
    bound_service_account_namespaces=<Consul installation namespace> \
    policies=<Connect CA policy> \
    ttl=1h
```

To find out the service account name of the Consul server,
you can run:

```shell-session
$ helm template --release-name ${RELEASE_NAME} --show-only templates/server-serviceaccount.yaml hashicorp/consul
```

## Configure the Vault Kubernetes auth role in the Consul on Kubernetes helm chart
Now you can configure the Consul Helm chart to use Vault as the Connect CA provider:

<CodeBlockConfig filename="values.yaml">

```yaml
global:
  secretsBackend:
    vault:
      enabled: true
      consulServerRole: consul-server
      consulClientRole: consul-client
      consulCARole: consul-ca
      connectCA:
        address: <the address of the Vault server>
        rootPKIPath: <the path to root PKI>
        intermediatePKIPath: <the path to intermediate PKI>
      ca:
        secretName: <vaultCASecret>
```

</CodeBlockConfig>

The `address` you provide to the `connectCA` configuration can be a Kubernetes DNS
address if the Vault cluster is running the same Kubernetes cluster.
The `rootPKIPath` and `intermediatePKIPath` should be the same as the ones
defined in your Connect CA policy. Behind the scenes, Consul will authenticate to Vault using a Kubernetes
service account using the [Kubernetes auth method](https://www.vaultproject.io/docs/auth/kubernetes) and will use the Vault token for any API calls to Vault. If the Vault token can not be renewed, Consul will re-authenticate to
generate a new Vault token.

The `vaultCASecret` is the Kubernetes secret that stores the CA Certificate that is used for Vault communication. To provide a CA, you first need to create a Kubernetes secret containing the CA. For example, you may create a secret with the Vault CA like so:

```shell-session
$ kubectl create secret generic vault-ca --from-file vault.ca=/path/to/your/vault/ca
```

### Secondary Datacenters

To configure Vault as the Connect CA in secondary datacenters, you need to make sure that the Root CA path is the same,
but the intermediate is different for each datacenter. In the `connectCA` Helm configuration for a secondary datacenter,
you can specify a `intermediatePKIPath` that is, for example, prefixed with the datacenter
for which this configuration is intended (e.g. `dc2/connect-intermediate`).

